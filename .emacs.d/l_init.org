#+TITLE: Literate Emacs Configuration
#+AUTHOR: Brihadeesh S
#+EMAIL: brihadeesh@protonmail.com
#+STARTUP: show4levels
#+CREATED: <2021-12-04 Sat>
#+MODIFIED: <2021-12-14 Tue>

* Prerequisites

Lexical binding is required for a lot of stuff here

#+BEGIN_SRC emacs-lisp :comments no :tangle yes
  ;; -*- lexical-binding: t -*-

  ;; don't follow symlinks? hopefully this solves the
  ;; `symbols function definition is void: org-file-name-concat' error
  (setq vc-follow-symlinks nil)
#+END_SRC


* Ensure UTF-8

#+begin_src emacs-lisp
  (set-language-environment 'utf-8)
  (prefer-coding-system 'utf-8)
#+end_src


* Native compilation setup

I think this has been moved to ~early-init.el~

#+BEGIN_SRC emacs-lisp :tangle no
  ;; (setq comp-speed 3)
  ;; (when (fboundp 'native-compile-async)
  ;;   (setq comp-deferred-compilation t
  ;;          comp-deferred-compilation-black-list '("/mu4e.*\\.el$")))

  ;; ;; compile under specified directory
  ;;   (native-compile-async "~/.sanemacs/straight/repos" 3 t)

#+END_SRC



* whoami

Doh

#+begin_src emacs-lisp
  (setq user-full-name "Brihadeesh S (They/Them)"
        user-mail-address "brihadeesh@protonmail.com")
#+end_src


* Performance enhancements

Maybe I'll understand what this is about one day

#+NAME: performance_enhancement
#+BEGIN_SRC emacs-lisp
  ;;; For performance
  (setq gc-cons-threshold 100000000)
  (setq read-process-output-max (* 1024 1024)) ;; 1mb

  (add-hook 'after-init-hook #'(lambda ()
                                 ;; restore after startup
                                 (setq gc-cons-threshold 100000000)))

  ;;; Fix this bug:
  ;;; https://www.reddit.com/r/emacs/comments/cueoug/the_failed_to_download_gnu_archive_is_a_pretty/
  (when (version< emacs-version "26.3")
    (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3"))
#+END_SRC



* No more garbage


** from customize API

This keeps the init.el cleaner and without junk from =customize.el=
API allows for an option to gitignore your =custom.el= cause it's
junk.

#+NAME: customize-disable
#+BEGIN_SRC emacs-lisp
;;; Offload the custom-set-variables to a separate file

    (setq custom-file "~/.emacs.d/custom.el")
    (unless (file-exists-p custom-file)
      (write-region "" nil custom-file))
    ;;; Load custom file. Don't hide errors. Hide success message
    (load custom-file nil t)
 #+END_SRC


** from backups and autosaves(?)

#+NAME: organise-junk
#+BEGIN_SRC emacs-lisp
  ;;; Put Emacs auto-save and backup files to one folder
  (defconst emacs-tmp-dir (expand-file-name (format "emacs%d" (user-uid)) temporary-file-directory))

  (setq
   backup-by-copying t                                        ; Avoid symlinks
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t
   auto-save-list-file-prefix emacs-tmp-dir
   auto-save-file-name-transforms `((".*" ,emacs-tmp-dir t))  ; Change autosave dir to tmp
   backup-directory-alist `((".*" . ,emacs-tmp-dir)))

  ;;; Lockfiles unfortunately cause more pain than benefit
  (setq create-lockfiles nil)
 #+END_SRC



* Package management


** Setup ~straight.el~

I'll be using ~use-package~ to organise and configure individual
packages into neater code blocks although the download will be handled
by ~straight.el~

#+NAME: straight-setup
#+BEGIN_SRC emacs-lisp
  (setq straight-use-package-by-default t)
  (setq straight-repository-branch "develop")

  ;; Bootstrap straight.el
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+END_SRC


** Install and configure =use-package=

~use-package~ is installed and managed by =straight.el= and in turn
packages used in this config are managed/organized by
~use-package~. There's something to do with integration with
~use-package~ on the [[https://github.com/raxod502/straight.el/blob/develop/README.md#integration-with-use-package][straight.el readme]]

#+NAME: use-use-package
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'use-package)
  (setq straight-host-usernames
        '((github . "brihadeesh")
          (gitlab . "peregrinator")
          (bitbucket . "peregrinator")))
#+END_SRC


** Minimal ~package.el~ setup only to browse packages

- State "IGNORE"     from              [2021-12-13 Mon 15:20]
Running =package-list-packages= includes them only for browsing

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives
               '("melpa" . "https://melpa.org/packages/"))
#+END_SRC



** Diminish for a cleaner modeline

~org-indent-mode~ doesn't get disabled by the default method.

#+begin_src emacs-lisp
    (use-package diminish
      :diminish auto-fill-function
      :diminish flyspell-mode
      :diminish visual-line-mode
    )

  (defun peremacs/diminish-org-indent ()
      (interactive)
      (diminish 'org-indent-mode ""))
  (add-hook 'org-indent-mode-hook 'peremacs/diminish-org-indent)

#+end_src


* Sane Defaults

Primarily bootlegged from [[https://sanemacs.com][Sanemacs]] and changed when appropriate (and
when I thought I understood what I was doing)


** Make *scratch* buffer and *minibuffer* blank

#+NAME: blank-startup
#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message "")
  (setq inhibit-startup-echo-area-message t)
  (setq inhibit-startup-message t)
  (setq initial-scratch-message nil)
#+END_SRC


** Make "Emacs" the *window title*

#+NAME: set-window-title
#+BEGIN_SRC emacs-lisp
  (setq-default frame-title-format '("Emacs"))
#+END_SRC


** Org-mode as the /initial major mode/

#+NAME: start-with-org
#+BEGIN_SRC emacs-lisp
  (setq initial-major-mode 'org-mode)
#+END_SRC


** TODO Disable native popups(?) and bell

#+BEGIN_SRC emacs-lisp
  ;; not sure what this is about
  ;; (setq-default indent-tabs-mode nil)
  ;; disable popups?
  ;; (setq pop-up-windows nil)
  ;; Disable bell sound
  (setq ring-bell-function 'ignore)
#+END_SRC


** Only *y or n prompts* like vim

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC


** Overwrite selected text

#+NAME: overwrite-active-region
#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC


** Join line to following line

Plagiarised from [[https://pragmaticemacs.com/emacs/join-line-to-following-line/][pragmatic emacs]]. For the reverse, emacs has a
slightly obscurely named command =delete-indentation= which is bound
to =M-^= which can be rather useful. From the help for the function
(which you can always look up using =C-h k M-^= or =C-h f
delete-indentation=)

#+NAME: concatenate-following-line
#+BEGIN_SRC emacs-lisp
  ;; join line to next line
  (global-set-key (kbd "C-j")
              (lambda ()
                    (interactive)
                    (join-line -1)))
#+END_SRC


** Delete blank lines and whitespace interactively

Plagiarised from [[https://pragmaticemacs.com/emacs/delete-blank-lines-and-shrink-whitespace/][pragmatic emacs]]

#+NAME: shrink-whitespace
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-SPC") 'shrink-whitespace)
#+END_SRC


** Multiple cursors

This is like =C-v=, a visual mode in vim/neovim. I stole this from
[[https://pragmaticemacs.com/emacs/multiple-cursors/][pragmatic emacs]].

#+NAME: multiple-cursors
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c m c") 'peremacs/edit-lines)
#+END_SRC


** Autoupdate buffer if files has changed on disk

#+NAME: reload-buffer-on-modification
#+BEGIN_SRC emacs-lisp
    (global-auto-revert-mode t)
#+END_SRC


** Whitespace mopup

#+NAME: del-whitespace
#+BEGIN_SRC emacs-lisp
      (add-hook 'before-save-hook
                'delete-trailing-whitespace) ;; Delete trailing whitespace on save
#+END_SRC


** Simpler kill buffer behaviour

#+NAME: buffer-killer
#+BEGIN_SRC emacs-lisp
  (defun peremacs/kill-this-buffer ()
    (interactive) (kill-buffer (current-buffer)))
  (global-set-key (kbd "C-x k") 'peremacs/kill-this-buffer)
#+END_SRC


** TODO Kill without accessing clipboard - reassess if this is really necessary

#+BEGIN_SRC emacs-lisp
  (defun peremacs/backward-kill-word ()
    (interactive "*")
    (push-mark)
    (backward-word)
    (delete-region (point) (mark)))

  (global-set-key (kbd "M-DEL") 'peremacs/backward-kill-word)
  (global-set-key (kbd "C-DEL") 'peremacs/backward-kill-word)
#+END_SRC


** Return to last position in buffer

Opens files at last position used. Something about this on [[https://www.emacswiki.org/emacs/SavePlace][Emacs Wiki]]

#+NAME: save-place
#+BEGIN_SRC emacs-lisp
  (save-place-mode 1)
#+END_SRC


** TODO Assorted keybindings - is this really necessary

#+NAME: manual-indent
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C->") 'indent-rigidly-right-to-tab-stop) ; Indent selection by one tab length
  (global-set-key (kbd "C-<") 'indent-rigidly-left-to-tab-stop)  ; De-indent selection by one tab length
#+END_SRC


** Reload Emacs configuration

I'm not sure I understand how this works entirely but [[https://github.com/joseph8th/literatemacs#tangle-and-reload][joseph8th's repo]]
suggests using =M-: (load-file user-init-file) RET= or evaluating that
same function interactively. I've modified the sanemacs reload config
function below hoping that it works but in that doesn't happen, this
first code block can be evaluated using =C-c C-c=:

#+NAME: reload-emacs
#+BEGIN_SRC emacs-lisp
  (defun reload-config ()
    (interactive)
    (load-file user-init-file))
#+END_SRC



** Prompt before closing Emacs

#+begin_src emacs-lisp
;; Confirm when killing Emacs
(setq confirm-kill-emacs (lambda (prompt)
                           (y-or-n-p-with-timeout prompt 2 nil)))
#+end_src

* TODO SSH for personal packages and magit

This needs a ton of work

#+BEGIN_SRC emacs-lisp
  (use-package keychain-environment
      :config
      (keychain-refresh-environment))

  ;; ;; import ssh deets from profile
  ;; (use-package exec-path-from-shell
  ;;   :config
  ;;   (exec-path-from-shell-copy-env "SSH_AGENT_PID")
  ;;   (exec-path-from-shell-copy-env "SSH_AUTH_SOCK"))
#+END_SRC


* Terminals

Vterm ftw

#+BEGIN_SRC emacs-lisp
  (use-package vterm
    ;; :ensure t
    :load-path "/usr/lib/libvterm.so.0.0.3"

    :init
    ;;  (setq vterm-term-environment-variable "eterm-256color")
    (setq vterm-disable-bold-font t)
    (setq vterm-kill-buffer-on-exit t)
    (setq vterm-module-cmake-args "-DUSE_SYSTEM_LIBVTERM=no")
    (setq vterm-always-compile-module t)
    (setq vterm-copy-exclude-prompt t))
#+END_SRC

Make vterm behave like a guake terminal and open below the main
window. This can be toggled and opens only one instance per window
(afaik). Considering using [[https://github.com/jixiuf/vterm-toggle#vterm-toggle-use-dedicated-buffer][this feature]] to not provide a dedicated
buffer to vterm so it sticks to the window it was launched with.

#+begin_src emacs-lisp
  (use-package vterm-toggle
    :bind
    (("C-M-'" . vterm-toggle-cd))
    :config
    ;; reset window layout after kill
    (setq vterm-toggle-reset-window-configration-after-exit t)
    ;; toggle behaviour - like a toggle keep it running
    (setq vterm-toggle-hide-method nil)
    ;; show vterm in a window at the bottom
    (setq vterm-toggle-fullscreen-p nil)
    (add-to-list 'display-buffer-alist
             '((lambda(bufname _) (with-current-buffer bufname (equal major-mode 'vterm-mode)))
                (display-buffer-reuse-window display-buffer-at-bottom)
                ;;(display-buffer-reuse-window display-buffer-in-direction)
                ;;display-buffer-in-direction/direction/dedicated is added in emacs27
                ;;(direction . bottom)
                ;;(dedicated . t) ;dedicated is supported in emacs27
                (reusable-frames . visible)
                (window-height . 0.3)))
    )
#+end_src


** IGNORE Eshell configuration

Make eshell pop under the main window and not create a window of it's
own.

#+begin_src emacs-lisp :tangle no
  (use-package eshell-toggle
    :after eshell
    :bind ("C-M-'" . eshell-toggle)
    :custom
    (eshell-toggle-size-fraction 3)
    (eshell-toggle-use-projectile-root t)
    (eshell-toggle-run-command nil))
#+end_src


* Code utilities


** Snippets

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :config
    (yas-global-mode 1)
    :diminish yas-minor-mode)
#+END_SRC


** TODO Syntax checking with Flycheck

#+begin_src emacs-lisp
  (use-package flycheck
    :defer t
    :hook
    (prog-mode . flycheck-mode)
    (org-mode . flycheck-mode)
    :diminish flycheck-mode
    )
#+end_src


** Autopaired parens

#+BEGIN_SRC emacs-lisp
    ;; auto-pair parens
    ;; (use-package autopair
    ;;   ;; :ensure t
    ;;   :init (setq autopair-autowrap t)
    ;;   :config (autopair-mode 1))

    ;; (use-package electric-pairs
    ;;   :straight (:type built-in)
    ;;   :config)

  ;; arguably the best package for managing parens
        ;; (use-package smartparens
        ;;   ;; :defer 1
        ;;   ;; :delight
        ;;   :custom (sp-escape-quotes-after-insert nil)
        ;;   :config (smartparens-global-mode 1))

  (electric-pair-mode 1)
#+END_SRC


** Don't add C-x,C-c,C-v; dont ask why though


#+BEGIN_SRC emacs-lisp
  (setq cua-enable-cua-keys nil)
  ;; for rectangles, CUA is nice
  (cua-mode t)
#+END_SRC


** Aggressive *indentation* coz OCD

...and I hate doing it manually and Emacs usually refuses to do it by
itself

#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :config (global-aggressive-indent-mode 1)
    :diminish aggressive-indent-mode)
#+END_SRC


** I hate arthropods

...except those that you can eat

#+BEGIN_SRC emacs-lisp
  (use-package bug-hunter)
#+END_SRC


** cl-libify

Convert all (deperecated) =cl= symbols to =cl-lib=

#+BEGIN_SRC emacs-lisp
  (use-package cl-libify
    :disabled)
#+END_SRC


** Iedit

A more intuitive way to alter all the occurrences of a word/keyword at once

#+BEGIN_SRC emacs-lisp
  (use-package iedit)
#+END_SRC


** Show line numbers in programming modes

#+NAME: linum-for-progmode
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook
                  (if (and (fboundp 'display-line-numbers-mode) (display-graphic-p))
                      #'display-line-numbers-mode
                    #'linum-mode))
#+END_SRC


** Open shell files from =~/bin= in =sh-mode=

Scope for adding more such shit?

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("/bin/" . sh-mode))
#+END_SRC


** Show matching parens

#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC


* Languages I (allegedly) use


** Vimscript for editing neovim init

...cause neovim sucks and I don't like leaving Emacs in the ideal
case. I might end up replacing this with a *lua config*

#+BEGIN_SRC emacs-lisp
  ;; vimrc syntax
  (use-package vimrc-mode)
  ;; :ensure t)
  (add-to-list 'auto-mode-alist '("\\.vim\\(rc\\)?\\'" . vimrc-mode))
#+END_SRC


** Lua mode?

I intend to learn and use lua for my neovim config.

#+BEGIN_SRC emacs-lisp
  (use-package lua-mode)
#+END_SRC


** Emacs Speaks Statistics for *R* and python(?)

Figure out babel/org-tangle or whatever because Emacs sucks for
RMarkdown and org-mode is generally better (see next bit for RMarkdown)

#+BEGIN_SRC emacs-lisp
  (use-package ess)
  ;; :ensure t
  (require `ess-r-mode)
#+END_SRC


** Polymode for RMarkdown syntax

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package poly-R)
  ;; :ensure t
  (add-to-list 'auto-mode-alist '("\\.md" . poly-markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.Rmd" . poly-ess-help+R-mode))
#+END_SRC


** C and C++ ???

Like really?

#+BEGIN_SRC emacs-lisp
  ;; (use-package cc-mode)
#+END_SRC


** AUCTex for LaTex editing + completion

#+BEGIN_SRC emacs-lisp
  ;; FIXME:
  ;; (use-package auctex
  ;;   :init
  ;;   (setq TeX-auto-save t)
  ;;   (setq TeX-parse-self t)
  ;;   (setq-default TeX-master nil))

  (use-package auctex
    :demand t
    :no-require t
    :mode ("\\.tex\\'" . TeX-latex-mode)
    :config
    (defun latex-help-get-cmd-alist ()    ;corrected version:
      "Scoop up the commands in the index of the latex info manual.
         The values are saved in `latex-help-cmd-alist' for speed."
      ;; mm, does it contain any cached entries
      (if (not (assoc "\\begin" latex-help-cmd-alist))
          (save-window-excursion
            (setq latex-help-cmd-alist nil)
            (Info-goto-node (concat latex-help-file "Command Index"))
            (goto-char (point-max))
            (while (re-search-backward "^\\* \\(.+\\): *\\(.+\\)\\." nil t)
              (let ((key (buffer-substring (match-beginning 1) (match-end 1)))
                    (value (buffer-substring (match-beginning 2)
                                             (match-end 2))))
                (add-to-list 'latex-help-cmd-alist (cons key value))))))
      latex-help-cmd-alist)

    (add-hook 'TeX-after-compilation-finished-functions
              #'TeX-revert-document-buffer))

  ;; (use-package company-auctex)
#+END_SRC


** Spellcheck

Finally figured this out from a [[https://redd.it/ahysvb][reddit post from 2019]].

#+BEGIN_SRC emacs-lisp
  ;; flyspell + aspell??
  (setq ispell-dictionary "en_GB")
  (setq ispell-program-name "hunspell")
  ;; below two lines reset the the hunspell to it STOPS querying locale!
  ;; (setq ispell-local-dictionary "en_GB") ; "en_GB" is key to lookup in `ispell-local-dictionary-alist`

  ;; tell ispell that apostrophes are part of words
  ;; and select Bristish dictionary
  ;; (setq ispell-local-dictionary-alist
  ;;             (quote ("UK_English" "[[:alpha:]]" "[^[:alpha:]]" "['’]" t ("-d" "en_GB") nil utf-8)))

  ;; hook for text mode
  (add-hook 'text-mode-hook 'flyspell-mode)
  ;; hook to check spelling for comments in code
  (add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+END_SRC


** Something like scrivener from Mac

...cause I'm gonna become a novelist and/or write large books in the
near future

#+BEGIN_SRC emacs-lisp
    (use-package binder)
    ;; (use-package binder-tutorial)
  #+END_SRC


* Git with Magit and gists with =gist.el=

#+NAME: magit-config
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind ("C-x g"    . magit-status))
#+END_SRC

~gist.el~ to manage github gists from here

#+NAME: gists-config
#+BEGIN_SRC emacs-lisp
  (use-package gist)
#+END_SRC


* View ePubs and PDFs in Emacs

#+BEGIN_SRC emacs-lisp
  (use-package nov
    :mode ("\\.epub\\'" . nov-mode)
    :config (nov-text-width 75))

  (use-package pdf-tools
    :magic ("%PDF" . pdf-view-mode)
    :mode ("\\.pdf\\'" . pdf-view-mode)
    :config (pdf-tools-install :no-query))

  ;; TODO this needs fixing idk why even
  ;; (use-package pdf-view
  ;;   :ensure nil
  ;;   :after pdf-tools
  ;;   :bind (:map pdf-view-mode-map
  ;;               ("C-s" . isearch-forward)
  ;;               ("d" . pdf-annot-delete)
  ;;               ("h" . pdf-annot-add-highlight-markup-annotation)
  ;;               ("t" . pdf-annot-add-text-annotation))
  ;;   :custom
  ;;   (pdf-view-display-size 'fit-page)
  ;;   (pdf-view-resize-factor 1.1)
  ;;   (pdf-view-use-unicode-ligther nil))
#+END_SRC



* Ledger for finance

I'm not entirely sure I can start with this yet but I think I've gotta
start working on paying of whatever debt I've accumulated.

#+NAME: pers_ledger
#+begin_src emacs-lisp
  (use-package ledger-mode
    :mode "\\.lgr\\'"

    :bind (:map ledger-mode-map
                ("TAB" . completion-at-point))

    :config
    (ledger-reports '(("bal" "%(binary) -f %(ledger-file) bal")
                      ;; ("bal this quarter" "%(binary) -f %(ledger-file) --period \"this quarter\" bal")
                      ;; ("bal last quarter" "%(binary) -f %(ledger-file) --period \"last quarter\" bal")
                      ;; ("reg" "%(binary) -f %(ledger-file) reg")
                      ;; ("payee" "%(binary) -f %(ledger-file) reg @%(payee)")
                      ("account" "%(binary) -f %(ledger-file) reg %(account)"))))
#+END_SRC


** IN-PROGRESS Prettier journaling for expenses

This is more like an ~org-mode~-like journal for personal expenses. I've
stolen this configuration from the author under the [[https://github.com/narendraj9/hledger-mode#usage][usage header]] of
the readme. It will need a lot more work to understand and I'm really
doing here so I've disabled it for now.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package hledger-mode
    ;; :straight t

    :mode ("\\.journal\\'" "\\.hledger\\'")

    ;; :commands hledger-enable-reporting

    :preface
    (defun hledger/next-entry ()
      "Move to next entry and pulse."
      (interactive)
      (hledger-next-or-new-entry)
      (hledger-pulse-momentary-current-entry))

    (defface hledger-warning-face
      '((((background dark))
         :background "Red" :foreground "White")
        (((background light))
         :background "Red" :foreground "White")
        (t :inverse-video t))
      "Face for warning"
      :group 'hledger)

    (defun hledger/prev-entry ()
      "Move to last entry and pulse."
      (interactive)
      (hledger-backward-entry)
      (hledger-pulse-momentary-current-entry))

    :bind (("C-c j" . hledger-run-command)
           :map hledger-mode-map
           ("TAB" . completion-at-point)
           ("C-c e" . hledger-jentry)
           ("M-p" . hledger/prev-entry)
           ("M-n" . hledger/next-entry))

    :init
    (setq hledger-jfile
          (expand-file-name "~/miscellany/personal/finance/accounting.journal")
          hledger-email-secrets-file (expand-file-name "secrets.el"
                                                       emacs-assets-directory))
    ;; Expanded account balances in the overall monthly report are
    ;; mostly noise for me and do not convey any meaningful information.
    (setq hledger-show-expanded-report nil)

    (when (boundp 'my-hledger-service-fetch-url)
      (setq hledger-service-fetch-url
            my-hledger-service-fetch-url))

    :config
    (add-hook 'hledger-view-mode-hook #'hl-line-mode)
    (add-hook 'hledger-view-mode-hook #'center-text-for-reading)

    (add-hook 'hledger-view-mode-hook
              (lambda ()
                (run-with-timer 1
                                nil
                                (lambda ()
                                  (when (equal hledger-last-run-command
                                               "balancesheet")
                                    ;; highlight frequently changing accounts
                                    (highlight-regexp "^.*\\(savings\\|cash\\).*$")
                                    (highlight-regexp "^.*credit-card.*$"
                                                      'hledger-warning-face))))))

    (add-hook 'hledger-mode-hook
              (lambda ()
                (make-local-variable 'company-backends)
                (add-to-list 'company-backends 'hledger-company)))))

  (use-package hledger-input
    :bind (("C-c e" . hledger-capture)
           :map hledger-input-mode-map
           ("C-c C-b" . popup-balance-at-point))

    :preface
    (defun popup-balance-at-point ()
      "Show balance for account at point in a popup."
      (interactive)
      (if-let ((account (thing-at-point 'hledger-account)))
          (message (hledger-shell-command-to-string (format " balance -N %s "
                                                            account)))
        (message "No account at point")))

    :config
    (setq hledger-input-buffer-height 20)
    (add-hook 'hledger-input-post-commit-hook #'hledger-show-new-balances)
    (add-hook 'hledger-input-mode-hook #'auto-fill-mode)
    (add-hook 'hledger-input-mode-hook
              (lambda ()
                (make-local-variable 'company-idle-delay)
                (setq-local company-idle-delay 0.1)))
    )
#+end_src


* Company for completions

Transient: only until I can figure corfu out

#+BEGIN_SRC emacs-lisp
  (use-package company
        ;; :ensure t
    ;; :bind
    ;;`company-mode-map
    ;; (("TAB" . company-select-next
    ;; ("M-n"     . company-select-next)
        ;;       ("M-p"     . company-select-previous)
    ;;  ))
    :config
    (setq company-idle-delay 0.0)
    :hook
    (after-init-hook . global-company-mode))
#+END_SRC

* TODO Corfu for completion-at-point (non-minibuffer kind)

This might need some more work - integration with [[https://github.com/minad/cape][minad's ~cape~]] for
various kinds of completions although he alleges this works well with
base Emacs.

#+NAME: corfu-competions
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package corfu
    :bind
    ;; Use TAB for cycling, default is `corfu-complete'.
    (:map corfu-map
          ("TAB" . corfu-next)
          ([tab] . corfu-next)
          ("S-TAB" . corfu-previous)
          ([backtab] . corfu-previous))

    :config
    ;; TAB-and-Go customizations
    ;; Enable cycling for `corfu-next/previous'
    (setq corfu-cycle t)
    ;; Disable candidate preselection
    (setq corfu-preselect-first nil)

    (corfu-global-mode +1))
#+END_SRC

** CAPE - extensions for corfu

Corfu needs ~cape~ to provide completion backends because it's extremely
stripped down. Will have to check what other backends I'll need to
enable.

#+begin_src emacs-lisp :tangle no
  (use-package cape
      :config
      (setq cape-dabbrev-min-length 2)

      :init
      ;; Add `completion-at-point-functions', used by `completion-at-point'.

      (dolist (backend '( cape-file cape-dabbrev cape-keyword cape-abbrev
                          cape-ispell cape-dict cape-symbol cape-line ))
                       (add-to-list 'completion-at-point-functions backend)))

      ;; (add-to-list 'completion-at-point-functions #'cape-file)
      ;; (add-to-list 'completion-at-point-functions #'cape-dabbrev)
      ;; (add-to-list 'completion-at-point-functions #'cape-keyword)
      ;; (add-to-list 'completion-at-point-functions #'cape-abbrev)
      ;; (add-to-list 'completion-at-point-functions #'cape-ispell)
      ;; (add-to-list 'completion-at-point-functions #'cape-dict)
      ;; (add-to-list 'completion-at-point-functions #'cape-symbol)
      ;; (add-to-list 'completion-at-point-functions #'cape-line))
#+end_src


* Undo tree

Helps revert to older versions of files in case I fuck up something
somewhere. Hmm. I doubt I ever use it so disabling it now.

#+BEGIN_SRC emacs-lisp
    (use-package undo-tree
      :init (global-undo-tree-mode)
      :diminish undo-tree-mode)
#+END_SRC


* Project management and navigation

#+BEGIN_SRC emacs-lisp
  ;; project management
  (use-package projectile
    ;; :ensure t
    :demand t
    :init (setq projectile-completion-system 'default)
    :bind-keymap
    ("C-c p" . projectile-command-map)
    ;; :diminish projectile-mode
    :config
    (setq projectile-project-search-path '("~/my_gits/" "~/dled_gits/" "~/Journal/" "~/Ledger"))
    (projectile-mode +1))

  ;; (use-package ibuffer-projectile
  ;;   :after ibuffer
  ;;   :preface
  ;;   (defun my/ibuffer-projectile ()
  ;;     (ibuffer-projectile-set-filter-groups)
  ;;     (unless (eq ibuffer-sorting-mode 'alphabetic)
  ;;       (ibuffer-do-sort-by-alphabetic)))
  ;;   :hook (ibuffer . my/ibuffer-projectile))
#+END_SRC



* Consistent and simpler keybinding assignment

#+BEGIN_SRC emacs-lisp
  (use-package general
    ;; :ensure t
    :config
    (general-define-key
     "M-/" 'hippie-expand
     "M-z" 'zap-to-char))
#+END_SRC



* Window Management
This ofc *doensn't work* on wayland and =pgtk= emacs but am I willing
to learn C++ and emacs-lisp well enough to contribute to porting this
to wayland/wlroots or something?


** EXWM

#+BEGIN_SRC emacs-lisp
  (use-package exwm
    ;; :ensure t

    :diminish

    :custom
    (exwm-workspace-number 4)

    ;; (defun exwm-start-process (command)
    ;;   "Start a process via a shell COMMAND."
    ;;   (interactive (list (read-shell-command "$ ")))
    ;;   (start-process-shell-command command nil command))

    ;; ((kbd "<s-return>") #'exwm-start-process)

    ;; (exwm-input-set-key (kbd "<s-return>") #'exwm-start-process)

    :config
    ;; This now has to be toggled separately in the `~/.xinitrc'
    ;; see https://www.reddit.com/r/emacs/comments/mjx2qd/conditional_loading_for_exwm_with_usepackage/gte7puu/
    (require 'exwm-config)
    ;; (exwm-config-default)

    ;; Effective use of EXWM requires the ability to return from char-mode to line-mode.
    ;; This will be performed with s-r.
    (exwm-input-set-key (kbd "s-r") #'exwm-reset)

    ;; Hide all windows except the current one.
    (exwm-input-set-key (kbd "s-o") #'delete-other-windows)

    ;; Close the current window and kill its buffer.
    (exwm-input-set-key (kbd "C-s-x") #'kill-buffer-and-window)

    ;; Close the current window without killing its buffer.
    (exwm-input-set-key (kbd "s-x") #'delete-window)

    ;; Open an Eshell buffer in the current buffer’s location.
    (exwm-input-set-key (kbd "C-z") #'eshell-find-eshell-here)

    ;;  Move point to the windows immediately around the current window.
    (exwm-input-set-key (kbd "s-h") #'windmove-left)
    (exwm-input-set-key (kbd "s-j") #'windmove-down)
    (exwm-input-set-key (kbd "s-k") #'windmove-up)
    (exwm-input-set-key (kbd "s-l") #'windmove-right)
    (exwm-input-set-key (kbd "s-w") #'exwm-workspace-switch))
#+END_SRC



** TODO Workspaces with perspective-el

Independent workspaces for different projects like profiles on RStudio
but perhaps a lot more dynamic. This might need more work hence adding
[[https://github.com/nex3/perspective-el][a link to the project page]] here.

#+BEGIN_SRC emacs-lisp
  (use-package perspective
    :demand t
    :bind
    ;; these work with selectrum/vertico i.e. `completing-read'
    ;; type completion systems that are appararently closer to
    ;; base Emacs functioning.
    (("C-x b" . persp-switch-to-buffer*)
    ;;("C-x k" . persp-kill-buffer*)
    )
    :config
    ;; Running `persp-mode' multiple times resets the perspective list...
  (unless (equal (default-value 'persp-mode) t)
    (persp-mode 1)))
#+END_SRC


** Undo disrupted window/frame arrangement after using some shit

Stolen from [[https://github.com/karthinks/emacs.d][Karthik Chikmaglur's emacs.d]]

#+begin_src emacs-lisp
  (use-package winner
    :disabled
    :commands winner-undo
    :bind (("C-x C-/" . winner-undo)
           ("s-/" . winner-undo)
           ("s-S-/" . winner-redo))
    :config
    (winner-mode +1))
#+end_src

** Ace-window

Simpler navigation between open Emacs windows

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    ;; :bind ((M-o . ace-window))
    :init
    (setq aw-keys '(?a ?s ?d ?f ?j ?k ?l ?o))
    (global-set-key (kbd "C-x o") 'ace-window)
    :diminish ace-window-mode)
#+END_SRC


Other actions that ~ace-window~ handles:

#+begin_src emacs-lisp :tangle no
  (defvar aw-dispatch-alist
  '((?x aw-delete-window "Delete Window")
	(?m aw-swap-window "Swap Windows")
	(?M aw-move-window "Move Window")
	(?c aw-copy-window "Copy Window")
	(?j aw-switch-buffer-in-window "Select Buffer")
	(?n aw-flip-window)
	(?u aw-switch-buffer-other-window "Switch Buffer Other Window")
	(?c aw-split-window-fair "Split Fair Window")
	(?v aw-split-window-vert "Split Vert Window")
	(?b aw-split-window-horz "Split Horz Window")
	(?o delete-other-windows "Delete Other Windows")
	(?? aw-show-dispatch-help))
  "List of actions for `aw-dispatch-default'.")
#+end_src


** TODO Sane native window management - needs work

Focuses new windows when created.

#+BEGIN_SRC emacs-lisp
  ;; Window management
  ;; focus new windows once created
  ;; (use-package window
  ;;   :straight (:type 'built-in)
  ;;   :bind (("C-x 3" . hsplit-last-buffer)
  ;;          ("C-x 2" . vsplit-last-buffer))
  ;;   :preface
  ;;   (defun hsplit-last-buffer ()
  ;;     "Gives the focus to the last created horizontal window."
  ;;     (interactive)
  ;;     (split-window-horizontally)
  ;;     (other-window 1))

  ;;   (defun vsplit-last-buffer ()
  ;;     "Gives the focus to the last created vertical window."
  ;;     (interactive)
  ;;     (split-window-vertically)
  ;;     (other-window 1)))
  #+END_SRC



** IN-PROGRESS Better popups

#+BEGIN_SRC emacs-lisp
  (use-package popper
      :bind (("C-`"   . popper-toggle-latest)
             ("M-`"   . popper-cycle)
             ("C-M-`" . popper-toggle-type))

      :init
      ;; assign windows to popper (to appear as popups)
      (setq popper-reference-buffers
            '("\\*Messages\\*"
              "Output\\*$"
              "\\*Backtrace\\*"
              "\\*Warnings\\*"
              "^Calc:"
              "^\\*ielm\\*"
              ;; terminals as popups
              "^\\*eshell.*\\*$" eshell-mode
              "^\\*shell.*\\*$" shell-mode
              "^\\*term.*\\*$" term-mode
              "^\\*vterm.*\\*$" vterm-mode
              help-mode
              compilation-mode
              ;;magit stuff
              "^magit:*" magit-mode))

      ;;grouping popups by projectile groups
      (setq popper-group-function #'popper-group-by-projectile)

      ;; popper UI configguration
      (setq popper-modeline nil)

      :config
      (popper-mode +1)
      ;; echo area hints?
      (popper-echo-mode +1)
      )
#+END_SRC


* Display keybinds following various prefixes such as =C-h=

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish which-key-mode
    :config
    (which-key-mode))
#+END_SRC



* Editing root files & privelege escalation for TRAMP if I ever use it

#+BEGIN_SRC emacs-lisp
    (use-package su
      ;; :config
      ;; (su-mode +1)
      )
#+END_SRC



* Minibuffer completions


** TODO Completion - is [[https://gitlab.com/protesilaos/mct][mct]] worth using?


** IGNORE Prescient command history with =M-x=

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package prescient
    :config
    (prescient-persist-mode 1))
  ;; (use-package selectrum-prescient)
#+END_SRC


** Access a list of recently edited files

Helps jump back into whatever I was doing before closing Emacs. Or my
laptop more like it.

#+BEGIN_SRC emacs-lisp
    (use-package recentf
      :init
      (setq recentf-max-menu-items 25
            recentf-auto-cleanup 'never
            recentf-keep '(file-remote-p file-readable-p))
      (recentf-mode 1))
  #+END_SRC



** IGNORE Selectrum for completions UI

If I rememeber right, this is closer to the default completion
behaviour in Emacs.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package selectrum
    :init
    (selectrum-mode +1)

    :config
    ;; to make sorting and filtering more intelligent
    (selectrum-prescient-mode +1)

    ;; to save your command history on disk, so the sorting gets more
    ;; intelligent over time
    (prescient-persist-mode +1))
#+END_SRC


** Vertico for completions UI

#+BEGIN_SRC emacs-lisp
  ;; Enable vertico
  (use-package vertico
    ;; pulls extensions as well?
    ;; :straight (:host github :repo "minad/vertico")

    :init
    (vertico-mode)

    :config
    ;; Grow and shrink the Vertico minibuffer
    (setq vertico-resize t)
    (advice-add #'tmm-add-prompt :after #'minibuffer-hide-completions))
#+END_SRC


*** TODO Vertico extensions

Again stolen from Karthik Chikmaglur and needs heavy work, hence not enabled

#+name: vertico-multiform
#+begin_src emacs-lisp :tangle no
  (use-package vertico-multiform
    :load-path "~/.emacs.d/lisp/vertico-extensions/"
    :commands vertico-multiform-mode
    :after vertico-flat
    :bind (:map vertico-map
                ("M-q" . vertico-multiform-grid)
                ("C-l" . vertico-multiform-unobtrusive)
                ("C-M-l" . embark-export))
    :init (vertico-multiform-mode 1)
    :config
    (setq vertico-multiform-categories
           '((file my/vertico-grid-mode reverse)
             (project-file my/vertico-grid-mode reverse)
             (imenu buffer)
             (consult-location buffer)
             (consult-grep buffer)
             (notmuch-result reverse)
             (minor-mode reverse)
             (reftex-label reverse)
             (bib-reference reverse)
             (xref-location reverse)
             (t unobtrusive)))
     (setq vertico-multiform-commands
           '((load-theme my/vertico-grid-mode reverse)
             (my/toggle-theme my/vertico-grid-mode reverse)
             (consult-dir-maybe reverse)
             (consult-dir reverse)
             (consult-history reverse)
             (consult-completion-in-region reverse)
             (completion-at-point reverse)
             (org-roam-node-find reverse)
             (embark-completing-read-prompter reverse)
             (embark-act-with-completing-read reverse)
             (embark-prefix-help-command reverse)
             (tmm-menubar reverse)))

     (defun vertico-multiform-unobtrusive ()
       "Toggle the quiet display."
       (interactive)
       (vertico-multiform--display-toggle 'vertico-unobtrusive-mode)
       (if vertico-unobtrusive-mode
           (vertico-multiform--temporary-mode 'vertico-reverse-mode -1)
         (vertico-multiform--temporary-mode 'vertico-reverse-mode 1))))
#+END_SRC

#+NAME: vertico-unobtrusive
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package vertico-unobtrusive
    :load-path "~/.local/share/git/vertico/extensions/"
    :after vertico-flat)
#+end_src

#+name vertico-grid
#+begin_src emacs-lisp :tangle no
    (use-package vertico-grid
      :load-path "~/.emacs.d/lisp/vertico-extensions/"
      :after vertico
      ;; :bind (:map vertico-map ("M-q" . vertico-grid-mode))
      :config
      (defvar my/vertico-count-orig vertico-count)
      (define-minor-mode my/vertico-grid-mode
        "Vertico-grid display with modified row count."
        :global t :group 'vertico
        (cond
         (my/vertico-grid-mode
          (setq my/vertico-count-orig vertico-count)
          (setq vertico-count 4)
          (vertico-grid-mode 1))
         (t (vertico-grid-mode 0)
            (setq vertico-count my/vertico-count-orig))))
      (setq vertico-grid-separator "    ")
      (setq vertico-grid-lookahead 50))
  #+end_src

#+name: vertico-quick
#+begin_src emacs-lisp :tangle no
(use-package vertico-quick
      :load-path "~/.emacs.d/lisp/vertico-extensions/"
      :after vertico
      :bind (:map vertico-map
             ("M-i" . vertico-quick-insert)
             ("C-'" . vertico-quick-exit)
             ("C-o" . vertico-quick-embark))
      :config
      (defun vertico-quick-embark (&optional arg)
        "Embark on candidate using quick keys."
        (interactive)
        (when (vertico-quick-jump)
          (embark-act arg))))
#+end_src

#+name: vertico-directory
#+begin_src emacs-lisp :tangle no
    (use-package vertico-directory
      :load-path "~/.emacs.d/lisp/vertico-extensions/"
      :hook (rfn-eshadow-update-overlay vertico-directory-tidy)
      :after vertico
      :bind (:map vertico-map
             ("DEL"   . vertico-directory-delete-char)
             ("M-DEL" . vertico-directory-delete-word)
             ("C-w"   . vertico-directory-delete-word)
             ("RET"   . vertico-directory-enter)))
#+end_src

#+name:vertico-repeat
#+begin_src emacs-lisp :tangle no
    (use-package vertico-repeat
      :load-path "~/.emacs.d/lisp/vertico-extensions/"
      :after vertico
      :bind (("C-x ." . vertico-repeat))
#+end_src

#+name:vertico-reverse
#+begin_src emacs-lisp :tangle no
    (use-package vertico-reverse
      ;; :disabled
      :load-path "~/.emacs.d/lisp/vertico-extensions/"
      :after vertico)
#+end_src

#+name:vertico-repeat
#+begin_src emacs-lisp :tangle no
    (use-package vertico-flat
      :load-path "~/.emacs.d/lisp/vertico-extensions/"
      ;; :bind (:map vertico-map
      ;;             ("M-q" . vertico-flat-mode))
      :after vertico)
#+end_src

#+name:vertico-buffer
#+begin_src emacs-lisp :tangle no
(use-package vertico-buffer
      :load-path "~/.emacs.d/lisp/vertico-extensions/"
      :after vertico
      ;; :hook (vertico-buffer-mode . vertico-buffer-setup)
      :config
      (setq vertico-buffer-display-action 'display-buffer-reuse-window))
#+end_src


** Orderless completion

Search for commands, buffers, etc with vertico without having to match
the order of words in the command. Adding spaces between keywords can
match commands with those words anywhere in them. This config was
bootlegged from [[https://github.com/minad/consult/wiki#minads-orderless-configuration][minad's config at the consult wiki]].

#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :config
  (defvar +orderless-dispatch-alist
    '((?% . char-fold-to-regexp)
      (?! . orderless-without-literal)
      (?`. orderless-initialism)
      (?= . orderless-literal)
      (?~ . orderless-flex)))

  ;; Recognizes the following patterns:
  ;; * ~flex flex~
  ;; * =literal literal=
  ;; * %char-fold char-fold%
  ;; * `initialism initialism`
  ;; * !without-literal without-literal!
  ;; * .ext (file extension)
  ;; * regexp$ (regexp matching at end)
  (defun +orderless-dispatch (pattern index _total)
    (cond
     ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
     ((string-suffix-p "$" pattern)
      `(orderless-regexp . ,(concat (substring pattern 0 -1) "[\x100000-\x10FFFD]*$")))
     ;; File extensions
     ((and
       ;; Completing filename or eshell
       (or minibuffer-completing-file-name
           (derived-mode-p 'eshell-mode))
       ;; File extension
       (string-match-p "\\`\\.." pattern))
      `(orderless-regexp . ,(concat "\\." (substring pattern 1) "[\x100000-\x10FFFD]*$")))
     ;; Ignore single !
     ((string= "!" pattern) `(orderless-literal . ""))
     ;; Prefix and suffix
     ((if-let (x (assq (aref pattern 0) +orderless-dispatch-alist))
          (cons (cdr x) (substring pattern 1))
        (when-let (x (assq (aref pattern (1- (length pattern))) +orderless-dispatch-alist))
          (cons (cdr x) (substring pattern 0 -1)))))))

  ;; Define orderless style with initialism by default
  (orderless-define-completion-style +orderless-with-initialism
    (orderless-matching-styles '(orderless-initialism orderless-literal orderless-regexp)))

  ;; You may want to combine the `orderless` style with `substring` and/or `basic`.
  ;; There are many details to consider, but the following configurations all work well.
  ;; Personally I (@minad) use option 3 currently. Also note that you may want to configure
  ;; special styles for special completion categories, e.g., partial-completion for files.
  ;;
  ;; 1. (setq completion-styles '(orderless))
  ;; This configuration results in a very coherent completion experience,
  ;; since orderless is used always and exclusively. But it may not work
  ;; in all scenarios. Prefix expansion with TAB is not possible.
  ;;
  ;; 2. (setq completion-styles '(substring orderless))
  ;; By trying substring before orderless, TAB expansion is possible.
  ;; The downside is that you can observe the switch from substring to orderless
  ;; during completion, less coherent.
  ;;
  ;; 3. (setq completion-styles '(orderless basic))
  ;; Certain dynamic completion tables (completion-table-dynamic)
  ;; do not work properly with orderless. One can add basic as a fallback.
  ;; Basic will only be used when orderless fails, which happens only for
  ;; these special tables.
  ;;
  ;; 4. (setq completion-styles '(substring orderless basic))
  ;; Combine substring, orderless and basic.
  ;;
  (setq completion-styles '(orderless)
        completion-category-defaults nil
        ;;; Enable partial-completion for files.
        ;;; Either give orderless precedence or partial-completion.
        ;;; Note that completion-category-overrides is not really an override,
        ;;; but rather prepended to the default completion-styles.
        ;; completion-category-overrides '((file (styles orderless partial-completion))) ;; orderless is tried first
        completion-category-overrides '((file (styles partial-completion)) ;; partial-completion is tried first
                                        ;; enable initialism by default for symbols
                                        (command (styles +orderless-with-initialism))
                                        (variable (styles +orderless-with-initialism))
                                        (symbol (styles +orderless-with-initialism)))
        orderless-component-separator #'orderless-escapable-split-on-space ;; allow escaping space with backslash!
        orderless-style-dispatchers '(+orderless-dispatch)))
#+END_SRC


** Persistent command history

Persist history over Emacs restarts. Vertico sorts by history position.

#+BEGIN_SRC emacs-lisp
(use-package savehist
    :init
    (savehist-mode))
#+END_SRC


** A few more useful configurations

#+BEGIN_SRC emacs-lisp
  ;; (use-package emacs
    ;; :init
    ;; Add prompt indicator to `completing-read-multiple'.
    ;; Alternatively try `consult-completing-read-multiple'.
    (defun crm-indicator (args)
      (cons (concat "[CRM] " (car args)) (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
    ;; Vertico commands are hidden in normal buffers.
    ;; (setq read-extended-command-predicate
    ;;       #'command-completion-default-include-p)

    ;; Enable recursive minibuffers
    (setq enable-recursive-minibuffers t)
    ;; )
#+END_SRC


** Richer annotations in minubuffer

#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :after vertico

    ;; The :init configuration is always executed (Not lazy!)
    :init

    ;; Must be in the :init section of use-package such that the mode gets
    ;; enabled right away. Note that this forces loading the package.
    (marginalia-mode)

    ;; When using Selectrum, ensure that Selectrum is refreshed when cycling annotations.
    ;; (advice-add #'marginalia-cycle :after
    ;;             (lambda () (when (bound-and-true-p selectrum-mode) (selectrum-exhibit 'keep-selected))))

    ;; Prefer richer, more heavy, annotations over the lighter default variant.
    ;; E.g. M-x will show the documentation string additional to the keybinding.
    ;; By default only the keybinding is shown as annotation.
    ;; Note that there is the command `marginalia-cycle' to
    ;; switch between the annotators.
    ;; (setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    )
#+END_SRC


** Consult adds more minibuffer functionality

#+BEGIN_SRC emacs-lisp
  (use-package consult
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind
    (("C-x B" . consult-buffer)
     ("C-x 4 b" . consult-buffer-other-window)
     ("C-x 5 b" . consult-buffer-other-frame)
     ("M-g i" . consult-imenu)
     ("M-g I" . consult-project-imenu)
     ;; searching for files
     ("M-s f" . consult-find)
     ("M-s F" . consult-git-grep)
     ("M-s g" . consult-grep)
     ("M-s r" . consult-ripgrep)
     ("C-c f r" . consult-recent-file)
     ;; Isearch integration
     ("C-s" . consult-isearch)
     ("C-c L" . consult-outline)
     ("C-c L" . consult-org-heading)
     ;; yank from kill-ring
     ("M-y" . consult-yank-pop)
     )

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI. You may want to also
    ;; enable `consult-preview-at-point-mode` in Embark Collect buffers.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    :config
    ;; Configure the narrowing key.
    (setq consult-narrow-key "<") ;; (kbd "C-+")

    ;; Configure a function which returns the project
    ;; root directory - projectile.el (projectile-project-root)
    (autoload 'projectile-project-root "projectile")
    (setq consult-project-root-function #'projectile-project-root)

    ;; use consult with perspective.el
    (consult-customize consult--source-buffer :hidden t :default nil)

    (defvar consult--source-perspective
      (list :name     "Perspective"
	    :narrow   ?s
	    :category 'buffer
	    :state    #'consult--buffer-state
	    :default  t
	    :items    #'persp-get-buffer-names))

    (push consult--source-perspective consult-buffer-sources)
    )

  ;; Optionally add the `consult-flycheck' command.
  (use-package consult-flycheck
    :bind (:map flycheck-command-map
		("!" . consult-flycheck)))
#+END_SRC


** TODO Embark - actions; reorganise

This I've not used yet but makes a lot of stuff easier like
searchingfor the =definition= or the =help/info= page a highlighted
word from within the buffer or the minibuffer or even the minibuffer
completion list.

*Group with the rest of the packages from this family?*

#+BEGIN_SRC emacs-lisp
    (use-package embark
      :bind
      (("C-S-a" . embark-act)       ;; pick some comfortable binding
       ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

      :init
      ;; Optionally replace the key help with a completing-read interface
      (setq prefix-help-command #'embark-prefix-help-command)

      :config
      ;; Hide the mode line of the Embark live/completions buffers
      (add-to-list 'display-buffer-alist
                   '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                     nil
                     (window-parameters (mode-line-format . none)))))

    ;; Consult users will also want the embark-consult package.
    (use-package embark-consult
      :ensure t
      :after (embark consult)
      :demand t ; only necessary if you have the hook below
      ;; if you want to have consult previews as you move around an
      ;; auto-updating embark collect buffer
      :hook
      (embark-collect-mode . consult-preview-at-point-mode))
#+END_SRC




* IN-PROGRESS org-mode setup

- [X] Get the damn thing first
- [ ] Organise the thing - needs splitting into multiple code blocks.

#+BEGIN_SRC emacs-lisp
        (use-package org
          ;;:defer t
          ;;:hook (org-mode . dw/org-mode-setup)
          :config
          (setq org-ellipsis " ▾"
                org-hide-emphasis-markers t
                org-src-fontify-natively t
                org-fontify-quote-and-verse-blocks t
                org-src-tab-acts-natively t
                ;; org-edit-src-content-indentation 2
                org-hide-block-startup nil
                org-src-preserve-indentation nil
                ;; org-startup-folded 'content
                org-cycle-separator-lines 2
                org-capture-bookmark nil)

          ;;(setq org-modules
          ;;  '(org-crypt
          ;;      org-habit
          ;;      org-bookmark
          ;;      org-eshell
          ;;      org-irc))

          (setq org-refile-targets '((nil :maxlevel . 1)
                                     (org-agenda-files :maxlevel . 1)))

          (setq org-outline-path-complete-in-steps nil)
          (setq org-refile-use-outline-path t)

          ;; get something like this for regular emacs bindings
          ;;(evil-define-key '(normal insert visual) org-mode-map (kbd "C-j") 'org-next-visible-heading)
          ;;(evil-define-key '(normal insert visual) org-mode-map (kbd "C-k") 'org-previous-visible-heading)
          ;;(evil-define-key '(normal insert visual) org-mode-map (kbd "M-j") 'org-metadown)
          ;;(evil-define-key '(normal insert visual) org-mode-map (kbd "M-k") 'org-metaup)

          (org-babel-do-load-languages
           'org-babel-load-languages
           '((emacs-lisp . t)
             (R . t)
             ;;(ledger . t)
             ))

          (use-package org-superstar
            :after org
            :hook (org-mode . org-superstar-mode)
            :custom
            (org-superstar-remove-leading-stars t)
            (org-superstar-headline-bullets-list '("◉" "○" "●" "○" "●" "○" "●")))

          ;; Replace list hyphen with dot
       (font-lock-add-keywords 'org-mode
                               '(("^ *\\([-]\\) "
                                  (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

       ;; Make sure org-indent face is available
       (require 'org-indent)

       ;; Ensure that anything that should be fixed-pitch in Org files appears that way
       (set-face-attribute 'org-block nil :inherit 'fixed-pitch)
       (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
       (set-face-attribute 'org-formula nil :inherit 'fixed-pitch)
       (set-face-attribute 'org-code nil :inherit '(shadow fixed-pitch))
       (set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))
       (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
       (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
       (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
       (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)


       ;; block templates
       ;; This is needed as of Org 9.2
       (require 'org-tempo)

       (add-to-list 'org-structure-template-alist '("sh" . "src sh"))
       (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
       (add-to-list 'org-structure-template-alist '("li" . "src lisp"))
       (add-to-list 'org-structure-template-alist '("sc" . "src scheme"))
       (add-to-list 'org-structure-template-alist '("rr" . "src R"))
       (add-to-list 'org-structure-template-alist '("py" . "src python"))
       (add-to-list 'org-structure-template-alist '("lua" . "src lua"))
       (add-to-list 'org-structure-template-alist '("yaml" . "src yaml"))
       (add-to-list 'org-structure-template-alist '("json" . "src json"))

  )
#+END_SRC


** Display emphasis markers on hover

This package makes it much easier to edit Org documents when
org-hide-emphasis-markers is turned on. It temporarily shows the
emphasis markers around certain markup elements when you place your
cursor inside of them. No more fumbling around with = and *
characters!

#+BEGIN_SRC emacs-lisp
  (use-package org-appear
    :hook (org-mode . org-appear-mode))
#+END_SRC


** Sources for agenda tasks

Generates an agenda from wildcarded org files from the specified
directory

#+BEGIN_SRC emacs-lisp :tangle no
  ;; (setq org-agenda-files
  ;;       (file-expand-wildcards "~/org/*.org"))
#+END_SRC


** Display features


*** Autoindent/autofill turned on automatically

#+BEGIN_SRC emacs-lisp
  ;; Emacs ver 24+
  (add-hook 'org-mode-hook 'org-indent-mode)
  (setq org-startup-indented t)

  ;; organise paragraphs automatically
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
#+END_SRC


*** Tags and todo-keywords config

Todo-keywords are things like ~TODO~ and ~DONE~ and so on. Tags are for
classifying stuff by the general theme of what's being talked about.


**** todo-keywords
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO(t)" "IN-PROGRESS(i@/!)" "CHECK(c!)" "|" "DONE(d!)" "IGNORE(f!)"
                    )))
#+END_SRC


**** TODO tags
#+BEGIN_SRC emacs-lisp
  (setq org-tag-alist '((("misc" . ?m)
                        ("emacs" . ?e)
                        ("dotfiles" . ?d)
                        ("work" . ?w)
                        ("chore" . ?c)
                        ("blog" . ?b)
                        )))
#+END_SRC


*** TODO Capture templates

This will need to be looked at carefully. Roughly, I need to work out
if I'm going to be using ~org-agenda~ and if so, how will I be using
it. Adding tasks can be made much easier with this. I can also use
this for entering entries into ~org-journal~, making it a whole deal
easier. Perhaps to start off, [[https://orgmode.org/worg/org-tutorials/index.html][the org-mode tutorial]] might be a good
place to start. I've also got a simple enough config from a reddit
post in my [[file:person_el/sample-org-setup.el][unused local elisp libs]] too.


*** Bullets for non ordered list

#+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords 'org-mode
                          '(("^ +\\([-*]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))


    (use-package org-bullets
      :config (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

    ;; If like me, you’re tired of manually updating your tables of
    ;; contents, toc-org will maintain a table of contents at the first
    ;; heading that has a :TOC: tag.
#+END_SRC


*** =Table of contents= for org-mode files

#+BEGIN_SRC emacs-lisp
  (use-package toc-org
      :after org
      :hook (org-mode . toc-org-enable))
#+END_SRC

Alternatively

#+begin_src emacs-lisp :tangle no
(use-package org-make-toc
  :hook (org-mode . org-make-toc-mode))
#+end_src


** TODO Org-Babel for literate programming

Org-mode needs org-babel, ob-tangle, live pdf/html preview within
Emacs, hooks to enable auto-fill, linum-mode (?)


** IN-PROGRESS org-roam

Start off with networked note-taking in the hope that this *GTD* thing
really works for me. I'll still have to find something to schedule
tasks and organise time with maybe /pomodoro/? Not loading this until
I'm sure this reaches some tangible stage of completion.

#+begin_src emacs-lisp :tangle no
(use-package org-roam
  :straight t)
#+end_src


** Better commenting in org-mode code-blocks

Got this from a [[https://emacs.stackexchange.com/a/19741/23936][Stack Exchange answer]] to work around messed up
commenting using the default ~C-x C-;~ command. The older/default
command messes up lines, undos, and sometimes comment syntax as well.

#+begin_src emacs-lisp
;; allow comment region in the code edit buffer (according to language)
(defun my-org-comment-dwim (&optional arg)
  (interactive "P")
  (or (org-babel-do-key-sequence-in-edit-buffer (kbd "M-;"))
      (comment-dwim arg)))

;; make `C-c C-v C-x M-;' more convenient
(define-key org-mode-map
  (kbd "M-;") 'my-org-comment-dwim)
#+end_src


** TODO Journaling requirements

This needs better setting up and integration with either =Orgzly= or
=GitJournal= for android. iOS seems to have better apps though. Or
just make this workable with the termux version of Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package org-journal
    :init
    ;; Change default prefix key; needs to be set before loading org-journal
    (setq org-journal-prefix-key "C-c j ")

    :bind
    ;; (("C-c t" . journal-file-today)
    ;;  ("C-c y" . journal-file-yesterday))

    :config
    ;; Journal directory and files
    (setq org-journal-dir "~/Journal/entries/"
          org-journal-file-format "%Y/%m/%Y%m%d.org"
          org-journal-file-type 'daily
          org-journal-find-file 'find-file)

    ;; Journal file content
    (setq org-journal-date-format "%e %b %Y (%A)"
          org-journal-time-format "(%R)"
          org-journal-file-header "#+TITLE: Daily Journal\n#+STARTUP: showeverything")
    )
#+END_SRC



** TODO [[https://github.com/bdarcus/citar][Citar]] for reference management?

If I ever get down to writing papers, of course, I'd write them in
~org-mode~ or LaTeX so this should be useful considering =Mendeley
desktop= is bloat and I haven't a clue if FreeBSD even has
=Zotero=. This has additional setup stuff to do with Embark and the
rest of that family. This particular config only works with
~org-mode~. Needs a shit ton of work to properly setup.

Also perhaps check out [[https://github.com/jkitchin/org-ref][org-ref]] - it /seems a lot
simpler/. [[https://www.youtube.com/watch?v=2t925KRBbFc][Introduction to org-ref]] - a video ontroduction

#+BEGIN_SRC emacs-lisp :tangle no
  ;;(use-package citar
    ;;:no-require
    ;;:custom
    ;;(org-cite-global-bibliography '("~/bib/references.bib"))
    ;;(org-cite-insert-processor 'citar)
    ;;(org-cite-follow-processor 'citar)
    ;;(org-cite-activate-processor 'citar)
    ;; optional: org-cite-insert is also bound to C-c C-x C-@
    ;;:bind
    ;;(:map org-mode-map :package org ("C-c b" . #'org-cite-insert)))
#+END_SRC



** org-present for presentations

See [[https://github.com/daviwil/dotfiles/blob/9776d65c4486f2fa08ec60a06e86ecb6d2c40085/Emacs.org#presentations][dawiwil's section on this]] from his literate init for more about
this.


* Multimedia


** EMMS for music

#+begin_src emacs-lisp
  (use-package emms
    :commands emms
    :config
    (require 'emms-setup)
    (emms-standard)
    (emms-default-players)
    (emms-mode-line-disable)
    (setq emms-source-file-default-directory "~/Music/")
    ;;(dw/leader-key-def
      ;;"am"  '(:ignore t :which-key "media")
      ;;"amp" '(emms-pause :which-key "play / pause")
      ;;"amf" '(emms-play-file :which-key "play file"))
    )
#+end_src


** mpv for video

#+begin_src emacs-lisp
  (use-package mpv)
#+end_src


* Web surfing and more

Got most of these from [[https://github.com/daviwil/dotfiles/blob/9776d65c4486f2fa08ec60a06e86ecb6d2c40085/Emacs.org][daviwil]]'s literate configuration


** Gemini

#+begin_src emacs-lisp
  (use-package elpher)
#+end_src


** TODO mail with mu4e

see [[https://github.com/daviwil/dotfiles/blob/9776d65c4486f2fa08ec60a06e86ecb6d2c40085/Mail.org][daviwil's mail.org]] and the configuration in his [[https://github.com/daviwil/dotfiles/blob/9776d65c4486f2fa08ec60a06e86ecb6d2c40085/Emacs.org#mail][literate config]].


** TODO Browser


** Elfeed for RSS

#+begin_src emacs-lisp
(use-package elfeed
  :commands elfeed
  :config
  (setq elfeed-feeds
    '("https://nullprogram.com/feed/"
      "https://guix.gnu.org/feeds/blog.atom"
      "https://valdyas.org/fading/feed/"
      "https://www.reddit.com/r/emacs/.rss")))
#+end_src


** IN-PROGRESS ERC for IRC
#+begin_src emacs-lisp :tangle no
  (use-package erc-hl-nicks
    :after erc)

  (use-package erc-image
    :after erc)

  (use-package erc
    :commands erc
    :hook (erc-track-list-changed . dw/on-erc-track-list-changed)
    :config
    (setq
        erc-nick "peregrinator"
        erc-user-full-name "Brihadeesh"
        erc-prompt-for-password nil
        erc-auto-query 'bury
        erc-join-buffer 'bury
        erc-track-shorten-start 8
        erc-interpret-mirc-color t
        erc-rename-buffers t
        erc-kill-buffer-on-part t
  ;;      erc-track-exclude '("#twitter_daviwil")
        erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE" "AWAY")
        erc-track-enable-keybindings nil
        erc-track-visibility nil ; Only use the selected frame for visibility
        erc-track-exclude-server-buffer t
        erc-fill-column 120
        erc-fill-function 'erc-fill-static
        erc-fill-static-center 20
        erc-image-inline-rescale 400
        erc-server-reconnect-timeout 10
        erc-server-reconnect-attempts 5
        erc-autojoin-channels-alist '(("irc.libera.chat" "#systemcrafters" "#emacs" "#guix"))
        erc-quit-reason (lambda (s) (or s "Ejecting from cyberspace"))
        erc-modules
        '(autoaway autojoin button completion fill irccontrols keep-place
            list match menu move-to-prompt netsplit networks noncommands
            readonly ring stamp track image hl-nicks notify notifications))

    (add-hook 'erc-join-hook 'bitlbee-identify)
    (defun bitlbee-identify ()
      "If we're on the bitlbee server, send the identify command to the &bitlbee channel."
      (when (and (string= "127.0.0.1" erc-session-server)
                 (string= "&bitlbee" (buffer-name)))
        (erc-message "PRIVMSG" (format "%s identify %s"
                                       (erc-default-target)
                                       (password-store-get "IRC/Bitlbee"))))))

  ;; TODO: idk how this works
  (defun peremacs/connect-irc ()
    (interactive)
    (erc-tls :server "irc.libera.chat" :port 3110 :nick "peregrinator"))
    ;; (erc
    ;;    :server "127.0.0.1" :port 6667
    ;;    :nick "daviwil" :password (password-store-get "IRC/Bitlbee")))

  ;; Thanks karthik!
  (defun erc-image-create-image (file-name)
    "Create an image suitably scaled according to the setting of
  'ERC-IMAGE-RESCALE."
    (let* ((positions (window-inside-absolute-pixel-edges))
          (width (- (nth 2 positions) (nth 0 positions)))
          (height (- (nth 3 positions) (nth 1 positions)))
          (image (create-image file-name))
          (dimensions (image-size image t))
          (imagemagick-p (and (fboundp 'imagemagick-types) 'imagemagick)))
                                          ; See if we want to rescale the image
      (if (and erc-image-inline-rescale
              (not (image-multi-frame-p image)))
          ;; Rescale based on erc-image-rescale
          (cond (;; Numeric: scale down to that size
                (numberp erc-image-inline-rescale)
                (if (> (cdr dimensions) erc-image-inline-rescale)
                    (create-image file-name imagemagick-p nil :height erc-image-inline-rescale)
                  image))
                (;; 'window: scale down to window size, if bigger
                (eq erc-image-inline-rescale 'window)
                ;; But only if the image is greater than the window size
                (if (or (> (car dimensions) width)
                        (> (cdr dimensions) height))
                    ;; Figure out in which direction we need to scale
                    (if (> width height)
                        (create-image file-name imagemagick-p nil :height  height)
                      (create-image file-name imagemagick-p nil :width width))
                  ;; Image is smaller than window, just give that back
                  image))
                (t (progn (message "Error: none of the rescaling options matched") image)))
        ;; No rescale
        image)))
#+end_src


* UI configuration


** Highlighted line-mode

#+NAME: cursorline
#+BEGIN_SRC emacs-lisp
  ;; cursorline
  (global-hl-line-mode 1)
#+END_SRC


** Solid window dividers

#+BEGIN_SRC emacs-lisp
  ;; (setq window-divider-default-right-width 1)
  ;; (setq window-divider-default-bottom-width 1)
  ;; (setq window-divider-default-places 'all)
  ;; (window-divider-mode)
  (setq window-divider-default-right-width 1)
  (setq window-divider-default-bottom-width 1)
  (setq window-divider-default-places 'right-only)
  (add-hook 'after-init-hook #'window-divider-mode)
#+END_SRC


** Something about underlines

Underline line at descent position, not baseline position

#+BEGIN_SRC emacs-lisp
  (setq x-underline-at-descent-line t)
#+END_SRC


** IGNORE figure this out too - No ugly button for checkboxes

#+BEGIN_SRC emacs-lisp :tangle no
  (setq widget-image-enable nil)
#+END_SRC


** Cursor configuration

#+BEGIN_SRC emacs-lisp
  (set-default 'cursor-type  '(bar . 2))
  (blink-cursor-mode 1)
#+END_SRC


** Line-number format

#+BEGIN_SRC emacs-lisp
        (setq linum-format "%4d ")
  #+END_SRC


** Visual not audible bell

Flashes modeline for warnings from [[https://github.com/purcell/mode-line-bell][purcell]]

#+BEGIN_SRC emacs-lisp
    ;; No sound
    (setq ring-bell-function 'ignore)

    (use-package mode-line-bell
      :config
      (mode-line-bell-mode))
#+END_SRC



** No Tooltips

#+BEGIN_SRC emacs-lisp
  (tooltip-mode 0)
#+END_SRC


** Minibuffer appearance?

As per [[https://www.reddit.com/r/emacs/comments/rxa29k/is_it_possible_to_have_a_window_which_is_just_the/hrhvrqw/][Hamilton9508's comment]] he makes a single minibuffer-only frame
across the bottom of the Emacs window and so the rest of the frames
have only a single buffer (i.e. the buffer being edited/used) and no
minubuffer of it's own. Not sure if this will work for me but I'll
perhaps give it a shot.

#+begin_src emacs-lisp
  (setq minibuffer-frame-alist '(
              (name . "minibuf")
              (menu-bar-lines . 0)
              (vertical-scroll-bars . nil)
              (auto-raise . t)
              (sticky . t)
              (left . 0)
              (top . -1)
              (height . 1)
              (internal-border-width . 0)
              (minibuffer . only)))
#+end_src


** Fringe

No fringe but nice glyphs for truncated and wrapped lines

#+BEGIN_SRC emacs-lisp
  (fringe-mode '(0 . 0))
#+END_SRC


** Minimalist and ordered mode-line

People seem to use packages for this. I've considered using the
[[https://github.com/seagle0128/doom-modeline][doom-modeline]] but it seems to be pretty heavy in terms of dependencies
and I'd like a mode-line with a much more fundamental interface
although it's still a good contender considering it's very simple to
configure. I'm also considering [[https://github.com/gexplorer/simple-modeline][simple-mode-line]].


*** TODO Mode-line

For now I'll stick to using a set of functions shared by [[https://www.reddit.com/r/emacs/comments/mmqjjw/how_rightalign_items_in_modeline/gttjpc4/][u/pkkm]] /on
right aligning items on modeline/. I still need to figure out how to
use this properly and perhaps replace the next section.

#+name: complex-modeline-setup
#+begin_src emacs-lisp :tangle no :fold t
        ;;; Alignment.
      ;; Fill functions are from <https://github.com/milkypostman/powerline>.

      (defvar ml-text-scale-factor 1.0
        "Scale of mode-line font size to default font size, as a float.
        This is needed to make sure that text is properly aligned.")

      (defun ml-fill-to-center (reserve face)
        "Return empty space to the center, leaving RESERVE space on the right."
        (when ml-text-scale-factor
          (setq reserve (* ml-text-scale-factor reserve)))
        (propertize " "
                    'display `((space :align-to (- (+ center (.5 . right-margin))
                                                   ,reserve
                                                   (.5 . left-margin))))
                    'face face))

      (defun ml-fill-to-right (reserve face)
        "Return empty space, leaving RESERVE space on the right."
        (when ml-text-scale-factor
          (setq reserve (* ml-text-scale-factor reserve)))
        (when (and window-system (eq 'right (get-scroll-bar-mode)))
          (setq reserve (- reserve 2))) ; Powerline uses 3 here, but my scrollbars are narrower.
        (propertize " "
                    'display `((space :align-to (- (+ right right-fringe right-margin)
                                                   ,reserve)))
                    'face face))

      (defun ml-render-2-part (left right &optional fill-face)
        (concat left
                (ml-fill-to-right (string-width (format-mode-line right)) fill-face)
                right))

      (defun ml-render-3-part (left center right &optional fill-face)
        (concat left
                (ml-fill-to-center (/ (string-width (format-mode-line center)) 2.0) fill-face)
                center
                (ml-fill-to-right (string-width (format-mode-line right)) fill-face)
                right))

    ;; modeline content?
  (setq-default mode-line-format
                  '((:eval
                     (simple-mode-line-render
                      ;; Left.
                      (quote (" %5l:%2c "
                              "%e %1* "
                              mode-line-buffer-identification
                              " %3p"))
                      ;; Right.
                      (quote (mode-line-frame-identification
                              mode-line-modes
                              mode-line-misc-info))))))

#+end_src


*** IN-PROGRESS simplistic left-right alignment

Or to keep things legible and simple, [[https://emacs.stackexchange.com/a/37270/23936][ideasman42's solution]], except it
doesn't work well. Will revisit later

#+name: does-not-work-mode-line
#+begin_src emacs-lisp :tangle no
    (defun simple-mode-line-render (left right)
      "Return a string of `window-width' length.
    Containing LEFT, and RIGHT aligned respectively."
      (let ((available-width
             (- (window-total-width)
                (+ (length (format-mode-line left))
                   (length (format-mode-line right))))))
        (append left
                (list (format (format "%%%ds" available-width) ""))
                right)))

    (setq-default mode-line-format
                  '((:eval
                     (simple-mode-line-render
                      ;; Left.
                      (quote (" %5l:%2c "
                              "%e %1* "
                              mode-line-buffer-identification
                              " %3p"))
                      ;; Right.
                      (quote (mode-line-frame-identification
                              mode-line-modes
                              mode-line-misc-info))))))
#+end_src


*** ~simple-mode-line~ because it's apparently simple

Was hoping I'd get a very minimalist mode-line like Karthik (who's
somehow becoming something of an obsession now).

#+name: sml-config
#+begin_src emacs-lisp
  (use-package smart-mode-line
    :commands sml/setup
    :init
    (setq sml/theme nil)
    (sml/setup)
    (unless (version< emacs-version "28.0")
      (setq mode-line-misc-info
            '((which-function-mode
               (which-func-mode
                ("" which-func-format " ")))
              ;; (global-mode-string
              ;;  ("" global-mode-string))
              )))
    :config
    (setq sml/mode-width 'full)
    )
#+end_src


*** TODO battery on mode-line

#+BEGIN_SRC emacs-lisp
  ;; (use-package battery
  ;;   :straight (:type built-in)
  ;;   ;; :type built-in
  ;;   :config
  ;;   (setq battery-mode-line-format " [%b%p%%]"
  ;;         battery-mode-line-limit 95
  ;;         battery-update-interval 180
  ;;         battery-load-low 20
  ;;         battery-load-critical 10)
  ;;   :hook after-init)
#+END_SRC


** Font configuration


*** Setting a font

#+BEGIN_SRC emacs-lisp
  ;; (set-face-font 'default "Input:size=10")
  ;; (set-face-font 'default "Unifont Medium 8")
  ;; (set-face-font 'default "Sudo Light 9")
  ;; (set-face-font 'default "Roboto Mono-7.5")
  ;; (set-face-font 'default "Anka/Coder:pixelsize=10")
  ;; (set-face-font 'default "Cascadia Mono:style=Light:size=10")
  ;; (set-face-font 'default "Monoid-7")
  ;; (set-face-font 'default "Iosevka-8")
  ;; (set-face-font 'default "mononoki-7.5")
  ;; (set-face-font 'default "Consolas-8")
  (set-face-font 'default "Hack-7.5")
  ;; (set-face-font 'default "Liga SFMono Nerd Font-7.5")
  ;; (set-face-font 'default "xos4 Terminus-9")
  ;; (set-face-font 'default "Anonymous Pro Minus-8.5")
  ;; (set-face-font 'default "Dina-8")
  ;; (set-face-font 'default "Droid Sans Mono-7.5")
  ;; (set-face-font 'default "Inconsolata-9")
#+END_SRC


*** Line spacing

Usually 0, less if possible but Emacs doesn't allow for that.

#+BEGIN_SRC emacs-lisp
  ;; Line spacing, can be 0 for code and 1 or 2 for text
  (setq-default line-spacing 0)
#+END_SRC


** Editor theme


*** IGNORE Initial config for moody I guess

Something to do with cleaner modeline for =moody.el= although I'm not
sure it works this way.

#+BEGIN_SRC emacs-lisp :tangle no
  (let ((line (face-attribute 'mode-line :underline)))
    (set-face-attribute 'mode-line          nil :overline line)
    (set-face-attribute 'mode-line-inactive nil :overline line)
    (set-face-attribute 'mode-line-inactive nil :underline line)
    (set-face-attribute 'mode-line          nil :box nil)
    (set-face-attribute 'mode-line-inactive nil :box nil)
    (set-face-attribute 'mode-line-inactive nil :box nil))
#+END_SRC


*** Externally sourced


**** Modus themes from Protesilaos!

This might need additional setting since modus themes are now included
within Emacs

#+BEGIN_SRC emacs-lisp
  (use-package modus-themes
      :config

      (setq modus-themes-bold-constructs t
            modus-themes-italic-constructs t
            modus-themes-region 'no-extend
            modus-themes-mode-line '(2)
            modus-themes-prompts '(backgound bold intense)
            modus-themes-completions 'opinionated
            modus-themes-hl-line 'accented
            modus-themes-intense-markup t
            modus-themes-region '(no-extend bg-only)
            modus-themes-org-block 'gray-background
            modus-themes-subtle-line-numbers t)

      (defun peremacs/call-modus-operandi ()
        (interactive)
        ;; heading backgrounds work better here
        (setq modus-themes-headings
              '((1 . (overline background semibold 1.2))
                (2 . (overline background semibold 1.1))
                (3 . (overline background semibold))
                (4 . (background semibold))
                (t . (regular))))
        (modus-themes-load-operandi))

      (defun peremacs/call-modus-vivendi ()
        (interactive)
        (setq modus-themes-headings
              '((1 . (overline semibold 1.2))
                (2 . (overline semibold 1.1))
                (3 . (overline semibold))
                (4 . (semibold))
                (t . (regular))))
        (modus-themes-load-vivendi))


      ;; set semibold as the bold face
      ;; (for those fonts that provide this face)
      ;; (set-face-attribute 'bold nil :weight 'semibold)

      ;; Load the theme files before enabling a theme
      (modus-themes-load-themes)

      ;; Load the theme of your choice:
      (peremacs/call-modus-operandi)
      ;; (peremacs/call-modus-vivendi)
      )
#+END_SRC


**** IN-PROGRESS Wilmersdorf for dark theme

I saw this on [[https://github.com/hlissner/emacs-doom-themes][doom-themes]] but I don't want to pull all of those just
for this, so installing from it's [[https://github.com/ianyepan/wilmersdorf-emacs-theme][GitHub]] using ~straight.el~. But it
fails to load with ~use-package~ so I'm going to have to do it manually.

#+begin_src emacs-lisp :tangle no
  (use-package wilmersdorf
    :straight(:type git :host github
                    :repo "ianyepan/wilmersdorf-emacs-theme"
                    ;; :files ("*.el")
                    )

    :config
    (load-theme 'wilmersdorf t))
#+end_src

The download/setup process should look like this but it'll need some
work before I can full automate it (since this is a repo that uses
stow and I'd prefer it be under version control)
#+begin_src sh :tangle no
  mkdir ~/.emacs.d/themes
  cd ~/.emacs.d/themes
  wget https://raw.githubusercontent.com/ianyepan/wilmersdorf-emacs-theme/master/wilmersdorf-theme.el
#+end_src

#+begin_src emacs-lisp
  (add-to-list 'custom-theme-load-path "~/.emacs.d/themes/")
  ;; (load-theme 'wilmersdorf t)
#+end_src


**** TODO Elegant Emacs from Nicolas Rougier

Somehow figure out how to incorporate my edits into this - they were
definitely a lot better for my workflow (doh)

#+BEGIN_SRC emacs-lisp
  (use-package nano-theme
    :straight (:host github :repo "rougier/nano-theme")

    ;; load theme separately
    ;; (nano-light)
    )
#+END_SRC

This is my fork

#+BEGIN_SRC emacs-lisp :tangle no
;; I'll have to manually load the theme I guess because this shit is a mess.
  (use-package elegant-emacs
    :straight (elegant-emacs :type git :host github :repo "brihadeesh/elegant-emacs"))
#+END_SRC


**** Expresso like Alessandro Yorba's vim theme ~breve~

#+BEGIN_SRC emacs-lisp
;; (use-package expresso-theme
  ;;   :recipe ()
  ;;   :config
  ;;   (load-theme expresso nil t))
#+END_SRC


**** Zenburn

Needs no introduction

#+BEGIN_SRC emacs-lisp
  (use-package zenburn-theme
    :config
    ;; scale headings in org-mode
    (setq zenburn-scale-org-headlines nil)

    ;; scale headings in outline-mode
    (setq zenburn-scale-outline-headlines nil)
    ;; load theme
    ;; (load-theme 'zenburn t)
    ;; (let ((line (face-attribute 'mode-line :underline)))
    ;;   (set-face-attribute 'mode-line          nil :overline line)
    ;;   (set-face-attribute 'mode-line-inactive nil :overline line)
    ;;   (set-face-attribute 'mode-line-inactive nil :underline line)
    ;;   (set-face-attribute 'mode-line          nil :box nil)
    ;;   (set-face-attribute 'mode-line-inactive nil :box nil)
    ;;   (set-face-attribute 'mode-line-inactive nil :box nil))
    )
#+END_SRC


**** Commentary

An elegant theme highlighting comments only

#+BEGIN_SRC emacs-lisp
  (use-package commentary-theme
    ;;:config
    ;;(load-theme 'commentary t)
    )
#+END_SRC


*** IN-PROGRESS My themes (LOL)

Neither of these work using =straight.el= or =use-package=, together
or separately (afaik). If these work, I could maybe add some more of
my own.

Forked from the [[https://github.com/lthms/colorless-themes][colorless-themes macro]]. This includes my version of
the macro, original themes from Thomas Letan, and some additional
themes of my own that use this macro.

#+BEGIN_SRC emacs-lisp
  (use-package colourless-themes
    :straight (:host gitlab :repo "peregrinator/colourless-themes-el")
    ;;:config
    ;;(load-theme 'beelzebub t)
    )
#+END_SRC


** Pulse to locate cursor

Also stolen from Karthik Chikmaglur

#+begin_src emacs-lisp :tangle no
(use-package pulse
  :custom-face
  (pulse-highlight-start-face ((t (:inherit region))))
  (pulse-highlight-face ((t (:inherit region))))
  :hook (((dumb-jump-after-jump
           imenu-after-jump) . my/recenter-and-pulse)
         ((bookmark-after-jump
           magit-diff-visit-file
           next-error) . my/recenter-and-pulse-line))
  :init
  (add-hook 'after-make-frame-functions
            (defun my/pulse-type (_frame)
              (when window-system (setq pulse-flag t))))

  (with-no-warnings
    (defun my/pulse-momentary-line (&rest _)
      "Pulse the current line."
      (pulse-momentary-highlight-one-line (point)))

    (defun my/pulse-momentary (&rest _)
      "Pulse the region or the current line."
      (if (fboundp 'xref-pulse-momentarily)
          (xref-pulse-momentarily)
        (my/pulse-momentary-line)))

    (defun my/recenter-and-pulse(&rest _)
      "Recenter and pulse the region or the current line."
      (recenter)
      (my/pulse-momentary))

    (defun my/recenter-and-pulse-line (&rest _)
      "Recenter and pulse the current line."
      (recenter)
      (my/pulse-momentary-line))

    (defun my/pulse-momentary-upper-bound (&rest _)
      "Pulse the upper scrolling bound of the screen."
      (save-excursion
        (move-to-window-line next-screen-context-lines)
        (my/pulse-momentary-line)))

    (defun my/pulse-momentary-lower-bound (&rest _)
      "Pulse the lower scrolling bound of the screen."
      (save-excursion
        (move-to-window-line (- next-screen-context-lines))
        (my/pulse-momentary-line)))

    (advice-add 'scroll-up-command   :after #'my/pulse-momentary-upper-bound)
    (advice-add 'scroll-down-command :after #'my/pulse-momentary-lower-bound)
#+end_src
